<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Allolib: al::Buffer&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Allolib
   </div>
   <div id="projectbrief">C++ Components For Interactive Multimedia</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceal.html">al</a></li><li class="navelem"><a class="el" href="classal_1_1_buffer.html">Buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classal_1_1_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">al::Buffer&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classal_1_1_buffer.html" title="Buffer. ">Buffer</a>.  
 <a href="classal_1_1_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="al___buffer_8hpp_source.html">/home/andres/Documents/src/Allostuff/allolib/include/al/core/types/al_Buffer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for al::Buffer&lt; T, Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classal_1_1_buffer__inherit__graph.png" border="0" usemap="#al_1_1_buffer_3_01_t_00_01_alloc_01_4_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for al::Buffer&lt; T, Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classal_1_1_buffer__coll__graph.png" border="0" usemap="#al_1_1_buffer_3_01_t_00_01_alloc_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afda5584999b597f34f9f947645334000"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#afda5584999b597f34f9f947645334000">Buffer</a> (int <a class="el" href="classal_1_1_buffer.html#a2f87f7c9f57113d37aaece5216a61c15">size</a>=0)</td></tr>
<tr class="separator:afda5584999b597f34f9f947645334000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359a98bbf452157ab86a94e9d4af6293"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a359a98bbf452157ab86a94e9d4af6293">Buffer</a> (int <a class="el" href="classal_1_1_buffer.html#a2f87f7c9f57113d37aaece5216a61c15">size</a>, int <a class="el" href="classal_1_1_buffer.html#aabfa24f6957ccdedc2be9704836db390">capacity</a>)</td></tr>
<tr class="separator:a359a98bbf452157ab86a94e9d4af6293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfa24f6957ccdedc2be9704836db390"><td class="memItemLeft" align="right" valign="top"><a id="aabfa24f6957ccdedc2be9704836db390"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#aabfa24f6957ccdedc2be9704836db390">capacity</a> () const</td></tr>
<tr class="memdesc:aabfa24f6957ccdedc2be9704836db390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total capacity. <br /></td></tr>
<tr class="separator:aabfa24f6957ccdedc2be9704836db390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f87f7c9f57113d37aaece5216a61c15"><td class="memItemLeft" align="right" valign="top"><a id="a2f87f7c9f57113d37aaece5216a61c15"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a2f87f7c9f57113d37aaece5216a61c15">size</a> () const</td></tr>
<tr class="memdesc:a2f87f7c9f57113d37aaece5216a61c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size. <br /></td></tr>
<tr class="separator:a2f87f7c9f57113d37aaece5216a61c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8842a68545408aa72e6f89423f1089c8"><td class="memItemLeft" align="right" valign="top"><a id="a8842a68545408aa72e6f89423f1089c8"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a8842a68545408aa72e6f89423f1089c8">elems</a> () const</td></tr>
<tr class="memdesc:a8842a68545408aa72e6f89423f1089c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns C pointer to elements. <br /></td></tr>
<tr class="separator:a8842a68545408aa72e6f89423f1089c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc4b8c7b195200be4c21e649194d100"><td class="memItemLeft" align="right" valign="top"><a id="a3cc4b8c7b195200be4c21e649194d100"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a3cc4b8c7b195200be4c21e649194d100">elems</a> ()</td></tr>
<tr class="memdesc:a3cc4b8c7b195200be4c21e649194d100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns C pointer to elements. <br /></td></tr>
<tr class="separator:a3cc4b8c7b195200be4c21e649194d100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f3d672ced2576b8e0edb9ef4674e00"><td class="memItemLeft" align="right" valign="top"><a id="a36f3d672ced2576b8e0edb9ef4674e00"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a36f3d672ced2576b8e0edb9ef4674e00">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a36f3d672ced2576b8e0edb9ef4674e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element at index. <br /></td></tr>
<tr class="separator:a36f3d672ced2576b8e0edb9ef4674e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c272447eda3f20f137b10853d3547b7"><td class="memItemLeft" align="right" valign="top"><a id="a7c272447eda3f20f137b10853d3547b7"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a7c272447eda3f20f137b10853d3547b7">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:a7c272447eda3f20f137b10853d3547b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element at index (read-only) <br /></td></tr>
<tr class="separator:a7c272447eda3f20f137b10853d3547b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263dd4c08edb1da52bf089350dda279b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a263dd4c08edb1da52bf089350dda279b">assign</a> (int n, const T &amp;v)</td></tr>
<tr class="memdesc:a263dd4c08edb1da52bf089350dda279b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign value to elements.  <a href="#a263dd4c08edb1da52bf089350dda279b">More...</a><br /></td></tr>
<tr class="separator:a263dd4c08edb1da52bf089350dda279b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab643d79172d4deb6a94e8b1ca1c9f2d0"><td class="memItemLeft" align="right" valign="top"><a id="ab643d79172d4deb6a94e8b1ca1c9f2d0"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#ab643d79172d4deb6a94e8b1ca1c9f2d0">last</a> ()</td></tr>
<tr class="memdesc:ab643d79172d4deb6a94e8b1ca1c9f2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last element. <br /></td></tr>
<tr class="separator:ab643d79172d4deb6a94e8b1ca1c9f2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39859ac2071bf961adc34a073acdf6b4"><td class="memItemLeft" align="right" valign="top"><a id="a39859ac2071bf961adc34a073acdf6b4"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>last</b> () const</td></tr>
<tr class="separator:a39859ac2071bf961adc34a073acdf6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff38ac067e4055f03e3536fe324500b1"><td class="memItemLeft" align="right" valign="top"><a id="aff38ac067e4055f03e3536fe324500b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#aff38ac067e4055f03e3536fe324500b1">reset</a> ()</td></tr>
<tr class="memdesc:aff38ac067e4055f03e3536fe324500b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets size to zero without deallocating allocated memory. <br /></td></tr>
<tr class="separator:aff38ac067e4055f03e3536fe324500b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521c18b768d939629a360056644c28ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a521c18b768d939629a360056644c28ec">resize</a> (int n)</td></tr>
<tr class="memdesc:a521c18b768d939629a360056644c28ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize buffer.  <a href="#a521c18b768d939629a360056644c28ec">More...</a><br /></td></tr>
<tr class="separator:a521c18b768d939629a360056644c28ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373f6c340c9a7333a46005d941dce099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a373f6c340c9a7333a46005d941dce099">size</a> (int n)</td></tr>
<tr class="memdesc:a373f6c340c9a7333a46005d941dce099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size of buffer.  <a href="#a373f6c340c9a7333a46005d941dce099">More...</a><br /></td></tr>
<tr class="separator:a373f6c340c9a7333a46005d941dce099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe105a0d004dec0a3d99f536f809abdd"><td class="memItemLeft" align="right" valign="top"><a id="afe105a0d004dec0a3d99f536f809abdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#afe105a0d004dec0a3d99f536f809abdd">append</a> (const T &amp;v, double growFactor=2)</td></tr>
<tr class="memdesc:afe105a0d004dec0a3d99f536f809abdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends element to end of buffer growing its size if necessary. <br /></td></tr>
<tr class="separator:afe105a0d004dec0a3d99f536f809abdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160a43a1dc43a3760acff824155167f1"><td class="memItemLeft" align="right" valign="top"><a id="a160a43a1dc43a3760acff824155167f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a160a43a1dc43a3760acff824155167f1">push_back</a> (const T &amp;v, double growFactor=2)</td></tr>
<tr class="memdesc:a160a43a1dc43a3760acff824155167f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">synonym for <a class="el" href="classal_1_1_buffer.html#afe105a0d004dec0a3d99f536f809abdd" title="Appends element to end of buffer growing its size if necessary. ">append()</a>: <br /></td></tr>
<tr class="separator:a160a43a1dc43a3760acff824155167f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbf45a7a95d059b0709177e88b54a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a3bbf45a7a95d059b0709177e88b54a39">append</a> (const <a class="el" href="classal_1_1_buffer.html">Buffer</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:a3bbf45a7a95d059b0709177e88b54a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append elements of another <a class="el" href="classal_1_1_buffer.html" title="Buffer. ">Buffer</a>.  <a href="#a3bbf45a7a95d059b0709177e88b54a39">More...</a><br /></td></tr>
<tr class="separator:a3bbf45a7a95d059b0709177e88b54a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051bc12e3d1217014d52d9c4e669b7da"><td class="memItemLeft" align="right" valign="top"><a id="a051bc12e3d1217014d52d9c4e669b7da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#a051bc12e3d1217014d52d9c4e669b7da">append</a> (const T *src, int len)</td></tr>
<tr class="memdesc:a051bc12e3d1217014d52d9c4e669b7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append elements of an array. <br /></td></tr>
<tr class="separator:a051bc12e3d1217014d52d9c4e669b7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad625ba475c4c50d897886940d972c309"><td class="memItemLeft" align="right" valign="top"><a id="ad625ba475c4c50d897886940d972c309"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#ad625ba475c4c50d897886940d972c309">repeatLast</a> ()</td></tr>
<tr class="memdesc:ad625ba475c4c50d897886940d972c309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat last element. <br /></td></tr>
<tr class="separator:ad625ba475c4c50d897886940d972c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27e6d7bb359b7a5c19b291b6cac1f60"><td class="memTemplParams" colspan="2">template&lt;int n, bool dup&gt; </td></tr>
<tr class="memitem:af27e6d7bb359b7a5c19b291b6cac1f60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classal_1_1_buffer.html#af27e6d7bb359b7a5c19b291b6cac1f60">expand</a> ()</td></tr>
<tr class="memdesc:af27e6d7bb359b7a5c19b291b6cac1f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new elements after each existing element.  <a href="#af27e6d7bb359b7a5c19b291b6cac1f60">More...</a><br /></td></tr>
<tr class="separator:af27e6d7bb359b7a5c19b291b6cac1f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt;<br />
class al::Buffer&lt; T, Alloc &gt;</h3>

<p><a class="el" href="classal_1_1_buffer.html" title="Buffer. ">Buffer</a>. </p>
<p>This buffer automatically expands itself as new elements are added. Additionally, its logical size can be reduced without triggering memory deallocations. </p>

<p class="definition">Definition at line <a class="el" href="al___buffer_8hpp_source.html#l00060">60</a> of file <a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afda5584999b597f34f9f947645334000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda5584999b597f34f9f947645334000">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classal_1_1_buffer.html">al::Buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classal_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Initial size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="al___buffer_8hpp_source.html#l00065">65</a> of file <a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a>.</p>

</div>
</div>
<a id="a359a98bbf452157ab86a94e9d4af6293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359a98bbf452157ab86a94e9d4af6293">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classal_1_1_buffer.html">al::Buffer</a>&lt; T, Alloc &gt;::<a class="el" href="classal_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Initial size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>Initial capacity </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="al___buffer_8hpp_source.html#l00071">71</a> of file <a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3bbf45a7a95d059b0709177e88b54a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbf45a7a95d059b0709177e88b54a39">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classal_1_1_buffer.html">al::Buffer</a>&lt; T, Alloc &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classal_1_1_buffer.html">Buffer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append elements of another <a class="el" href="classal_1_1_buffer.html" title="Buffer. ">Buffer</a>. </p>
<p>Note: not safe to apply this to itself </p>

<p class="definition">Definition at line <a class="el" href="al___buffer_8hpp_source.html#l00147">147</a> of file <a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a>.</p>

</div>
</div>
<a id="a263dd4c08edb1da52bf089350dda279b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263dd4c08edb1da52bf089350dda279b">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classal_1_1_buffer.html">al::Buffer</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign value to elements. </p>
<p>This function fills a <a class="el" href="classal_1_1_buffer.html" title="Buffer. ">Buffer</a> with n copies of the given value. Note that the assignment completely changes the buffer and that the resulting size is the same as the number of elements assigned. Old data may be lost. </p>

<p class="definition">Definition at line <a class="el" href="al___buffer_8hpp_source.html#l00095">95</a> of file <a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a>.</p>

</div>
</div>
<a id="af27e6d7bb359b7a5c19b291b6cac1f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27e6d7bb359b7a5c19b291b6cac1f60">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;int n, bool dup&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classal_1_1_buffer.html">al::Buffer</a>&lt; T, Alloc &gt;::expand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new elements after each existing element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>Expansion factor; new size is n times old size </td></tr>
    <tr><td class="paramname">dup</td><td>If true, new elements are duplicates of existing elements. If false, new elements are default constructed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="al___buffer_8hpp_source.html#l00168">168</a> of file <a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a>.</p>

</div>
</div>
<a id="a521c18b768d939629a360056644c28ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521c18b768d939629a360056644c28ec">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classal_1_1_buffer.html">al::Buffer</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize buffer. </p>
<p>This will set both the size and capacity of the buffer to the requested size. If the number is smaller than the current size the buffer is truncated, otherwise the buffer is extended and new elements are default-constructed. </p>

<p class="definition">Definition at line <a class="el" href="al___buffer_8hpp_source.html#l00110">110</a> of file <a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a>.</p>

</div>
</div>
<a id="a373f6c340c9a7333a46005d941dce099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373f6c340c9a7333a46005d941dce099">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classal_1_1_buffer.html">al::Buffer</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set size of buffer. </p>
<p>If the requested size is larger than the current capacity, then the buffer will be resized. </p>

<p class="definition">Definition at line <a class="el" href="al___buffer_8hpp_source.html#l00119">119</a> of file <a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="al___buffer_8hpp_source.html">al_Buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 19 2018 09:51:10 for Allolib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
