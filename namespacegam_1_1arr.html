<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Allolib: gam::arr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Allolib
   </div>
   <div id="projectbrief">C++ Components For Interactive Multimedia</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacegam_1_1arr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">gam::arr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classgam_1_1_array.html" title="Resizable array. ">Array</a> rank functions for numerical types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab90ab9c08e7ea9d0a4c2d06e59ed7e5e"><td class="memTemplParams" colspan="2"><a id="ab90ab9c08e7ea9d0a4c2d06e59ed7e5e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab90ab9c08e7ea9d0a4c2d06e59ed7e5e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#ab90ab9c08e7ea9d0a4c2d06e59ed7e5e">dot</a> (const T *src1, const T *src2, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:ab90ab9c08e7ea9d0a4c2d06e59ed7e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns dot-product of two arrays. <br /></td></tr>
<tr class="separator:ab90ab9c08e7ea9d0a4c2d06e59ed7e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249387dd66b85cebd2f470b9ea31e453"><td class="memTemplParams" colspan="2"><a id="a249387dd66b85cebd2f470b9ea31e453"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a249387dd66b85cebd2f470b9ea31e453"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a249387dd66b85cebd2f470b9ea31e453">sumSquares</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a249387dd66b85cebd2f470b9ea31e453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sum of values squared. <br /></td></tr>
<tr class="separator:a249387dd66b85cebd2f470b9ea31e453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57921e7a2bbcae73bf4e44c1390e9c41"><td class="memTemplParams" colspan="2"><a id="a57921e7a2bbcae73bf4e44c1390e9c41"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a57921e7a2bbcae73bf4e44c1390e9c41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a57921e7a2bbcae73bf4e44c1390e9c41">add</a> (T *dst, const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a57921e7a2bbcae73bf4e44c1390e9c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add source array to destination array. <br /></td></tr>
<tr class="separator:a57921e7a2bbcae73bf4e44c1390e9c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e742af71306a0b14b925490afabb9f"><td class="memTemplParams" colspan="2"><a id="af9e742af71306a0b14b925490afabb9f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af9e742af71306a0b14b925490afabb9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#af9e742af71306a0b14b925490afabb9f">add</a> (T *dst, const T *src1, const T *src2, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:af9e742af71306a0b14b925490afabb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two source arrays into destination array. <br /></td></tr>
<tr class="separator:af9e742af71306a0b14b925490afabb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf5cdbf8afae565d13f885df0d9e34e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2bf5cdbf8afae565d13f885df0d9e34e"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a2bf5cdbf8afae565d13f885df0d9e34e">addToRing</a> (T *ring, unsigned ringSize, unsigned ringTap, const T *src, unsigned len)</td></tr>
<tr class="memdesc:a2bf5cdbf8afae565d13f885df0d9e34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum elements from src into ring-buffer ring.  <a href="#a2bf5cdbf8afae565d13f885df0d9e34e">More...</a><br /></td></tr>
<tr class="separator:a2bf5cdbf8afae565d13f885df0d9e34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4c5708ff24e4614f1ab7c5b54c0a20"><td class="memItemLeft" align="right" valign="top"><a id="a1c4c5708ff24e4614f1ab7c5b54c0a20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a1c4c5708ff24e4614f1ab7c5b54c0a20">clip1</a> (float *arr, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a1c4c5708ff24e4614f1ab7c5b54c0a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip array values between [-1, 1]. <br /></td></tr>
<tr class="separator:a1c4c5708ff24e4614f1ab7c5b54c0a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab464b6505e0c6447c31ae23dc53a2c00"><td class="memTemplParams" colspan="2">template&lt;class T , class Index &gt; </td></tr>
<tr class="memitem:ab464b6505e0c6447c31ae23dc53a2c00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#ab464b6505e0c6447c31ae23dc53a2c00">cluster</a> (const T *src, Index *indices, unsigned &amp;numIndices, T threshold)</td></tr>
<tr class="memdesc:ab464b6505e0c6447c31ae23dc53a2c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds elements that are within a threshold of their nearest neighbors.  <a href="#ab464b6505e0c6447c31ae23dc53a2c00">More...</a><br /></td></tr>
<tr class="separator:ab464b6505e0c6447c31ae23dc53a2c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce19cef6bd78c706bce73c6a23f88db"><td class="memItemLeft" align="right" valign="top"><a id="a9ce19cef6bd78c706bce73c6a23f88db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compact</b> (float *dst, const float *src, unsigned len, unsigned chunkSize)</td></tr>
<tr class="separator:a9ce19cef6bd78c706bce73c6a23f88db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a6168fad3ea7c71f23a7c89e9871bf"><td class="memTemplParams" colspan="2"><a id="a14a6168fad3ea7c71f23a7c89e9871bf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a14a6168fad3ea7c71f23a7c89e9871bf"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a14a6168fad3ea7c71f23a7c89e9871bf">dot4</a> (const T *src1, const T *src2)</td></tr>
<tr class="memdesc:a14a6168fad3ea7c71f23a7c89e9871bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns dot-product of two arrays of length 4. <br /></td></tr>
<tr class="separator:a14a6168fad3ea7c71f23a7c89e9871bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd7813fd310b2aba0e0e1c02acc29b2"><td class="memTemplParams" colspan="2"><a id="aadd7813fd310b2aba0e0e1c02acc29b2"></a>
template&lt;class T , class Index &gt; </td></tr>
<tr class="memitem:aadd7813fd310b2aba0e0e1c02acc29b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#aadd7813fd310b2aba0e0e1c02acc29b2">extrema</a> (const T *src, unsigned len, Index &amp;indexMin, Index &amp;indexMax)</td></tr>
<tr class="memdesc:aadd7813fd310b2aba0e0e1c02acc29b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of min and max values. <br /></td></tr>
<tr class="separator:aadd7813fd310b2aba0e0e1c02acc29b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4b6b287382bc4c303acbcebcb3b2fd"><td class="memTemplParams" colspan="2">template&lt;class Ts , class Tb &gt; </td></tr>
<tr class="memitem:aff4b6b287382bc4c303acbcebcb3b2fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#aff4b6b287382bc4c303acbcebcb3b2fd">histogram</a> (const Ts *src, unsigned len, Tb *bins, unsigned numBins, Ts scale=1)</td></tr>
<tr class="memdesc:aff4b6b287382bc4c303acbcebcb3b2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute histogram of 'src'.  <a href="#aff4b6b287382bc4c303acbcebcb3b2fd">More...</a><br /></td></tr>
<tr class="separator:aff4b6b287382bc4c303acbcebcb3b2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7045f2203ec711c9dfd9100ebdccde74"><td class="memTemplParams" colspan="2"><a id="a7045f2203ec711c9dfd9100ebdccde74"></a>
template&lt;class Ts , class Tb &gt; </td></tr>
<tr class="memitem:a7045f2203ec711c9dfd9100ebdccde74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>histogram</b> (const Ts *src, unsigned len, Tb *bins, unsigned numBins, Ts scale, Ts offset)</td></tr>
<tr class="separator:a7045f2203ec711c9dfd9100ebdccde74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574565e7493660e2566589456aa6820"><td class="memTemplParams" colspan="2"><a id="a8574565e7493660e2566589456aa6820"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8574565e7493660e2566589456aa6820"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a8574565e7493660e2566589456aa6820">indexOfMax</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a8574565e7493660e2566589456aa6820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of maximum value. <br /></td></tr>
<tr class="separator:a8574565e7493660e2566589456aa6820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da18a9b7134245dd2dd387bdca00b04"><td class="memTemplParams" colspan="2"><a id="a9da18a9b7134245dd2dd387bdca00b04"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9da18a9b7134245dd2dd387bdca00b04"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a9da18a9b7134245dd2dd387bdca00b04">indexOfMaxNorm</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a9da18a9b7134245dd2dd387bdca00b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of maximum normed value (i.e., magnitude) <br /></td></tr>
<tr class="separator:a9da18a9b7134245dd2dd387bdca00b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5979d5991304e6ee9c26a407e5b1c23"><td class="memTemplParams" colspan="2"><a id="ad5979d5991304e6ee9c26a407e5b1c23"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad5979d5991304e6ee9c26a407e5b1c23"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#ad5979d5991304e6ee9c26a407e5b1c23">indexOfMin</a> (const T *src, unsigned len)</td></tr>
<tr class="memdesc:ad5979d5991304e6ee9c26a407e5b1c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of minimum value. <br /></td></tr>
<tr class="separator:ad5979d5991304e6ee9c26a407e5b1c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92adac78071b0c8c7b24c1de92a4cdbf"><td class="memTemplParams" colspan="2">template&lt;class Index &gt; </td></tr>
<tr class="memitem:a92adac78071b0c8c7b24c1de92a4cdbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a92adac78071b0c8c7b24c1de92a4cdbf">indicesComplement</a> (Index *indices, unsigned numIndices, unsigned maxNumIndices)</td></tr>
<tr class="memdesc:a92adac78071b0c8c7b24c1de92a4cdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets indices [numIndices, maxNumIndices) to complement indices.  <a href="#a92adac78071b0c8c7b24c1de92a4cdbf">More...</a><br /></td></tr>
<tr class="separator:a92adac78071b0c8c7b24c1de92a4cdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2195070f4b560bcccb54c6928ddace6"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class T3 &gt; </td></tr>
<tr class="memitem:ad2195070f4b560bcccb54c6928ddace6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#ad2195070f4b560bcccb54c6928ddace6">lineFit</a> (const T1 *src, unsigned len, T2 &amp;slope, T3 &amp;inter)</td></tr>
<tr class="memdesc:ad2195070f4b560bcccb54c6928ddace6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform linear least squares fitting of array.  <a href="#ad2195070f4b560bcccb54c6928ddace6">More...</a><br /></td></tr>
<tr class="separator:ad2195070f4b560bcccb54c6928ddace6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57140cc4ed6ad7e3a4a0e6d6576a3a94"><td class="memItemLeft" align="right" valign="top"><a id="a57140cc4ed6ad7e3a4a0e6d6576a3a94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a57140cc4ed6ad7e3a4a0e6d6576a3a94">linToDB</a> (float *arr, unsigned len, float minDB)</td></tr>
<tr class="memdesc:a57140cc4ed6ad7e3a4a0e6d6576a3a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from linear range [-1, 1] to normalized dB range [-1, 1]. <br /></td></tr>
<tr class="separator:a57140cc4ed6ad7e3a4a0e6d6576a3a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb6b3bbf615b929f0091d329bc96eb0"><td class="memTemplParams" colspan="2">template&lt;class Index , class T &gt; </td></tr>
<tr class="memitem:a6cb6b3bbf615b929f0091d329bc96eb0"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a6cb6b3bbf615b929f0091d329bc96eb0">maxima</a> (Index *dst, const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a6cb6b3bbf615b929f0091d329bc96eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates local maxima and writes their indices into 'dst'.  <a href="#a6cb6b3bbf615b929f0091d329bc96eb0">More...</a><br /></td></tr>
<tr class="separator:a6cb6b3bbf615b929f0091d329bc96eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18472e15b3a6a707c1c0dfc4c2f04dd"><td class="memTemplParams" colspan="2"><a id="ac18472e15b3a6a707c1c0dfc4c2f04dd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac18472e15b3a6a707c1c0dfc4c2f04dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#ac18472e15b3a6a707c1c0dfc4c2f04dd">mean</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:ac18472e15b3a6a707c1c0dfc4c2f04dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean (average) value of array values. <br /></td></tr>
<tr class="separator:ac18472e15b3a6a707c1c0dfc4c2f04dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0de6926e105973559b5d63e9036fd2"><td class="memTemplParams" colspan="2"><a id="a4d0de6926e105973559b5d63e9036fd2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d0de6926e105973559b5d63e9036fd2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a4d0de6926e105973559b5d63e9036fd2">meanNorm</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a4d0de6926e105973559b5d63e9036fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean norm of array values. <br /></td></tr>
<tr class="separator:a4d0de6926e105973559b5d63e9036fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c610491dd3b7c9e5618d068104b7ff"><td class="memTemplParams" colspan="2"><a id="af6c610491dd3b7c9e5618d068104b7ff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af6c610491dd3b7c9e5618d068104b7ff"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#af6c610491dd3b7c9e5618d068104b7ff">meanAbsDiff</a> (const T *src, unsigned len)</td></tr>
<tr class="memdesc:af6c610491dd3b7c9e5618d068104b7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mean absolute difference of array values. <br /></td></tr>
<tr class="separator:af6c610491dd3b7c9e5618d068104b7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af560cea1ff06a08c31604c2ae2956e38"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af560cea1ff06a08c31604c2ae2956e38"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#af560cea1ff06a08c31604c2ae2956e38">meanWeighted</a> (const T *src, const T *weights, unsigned len)</td></tr>
<tr class="memdesc:af560cea1ff06a08c31604c2ae2956e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns weighted mean of array values.  <a href="#af560cea1ff06a08c31604c2ae2956e38">More...</a><br /></td></tr>
<tr class="separator:af560cea1ff06a08c31604c2ae2956e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367de7e8249571e06fc9eaa44c3852ff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a367de7e8249571e06fc9eaa44c3852ff"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a367de7e8249571e06fc9eaa44c3852ff">meanWeightedIndex</a> (const T *weights, unsigned len)</td></tr>
<tr class="memdesc:a367de7e8249571e06fc9eaa44c3852ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns weighted mean in [0, len) of indices of weights.  <a href="#a367de7e8249571e06fc9eaa44c3852ff">More...</a><br /></td></tr>
<tr class="separator:a367de7e8249571e06fc9eaa44c3852ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af374fbc895ac5e033d59d41fe7cce6ff"><td class="memTemplParams" colspan="2"><a id="af374fbc895ac5e033d59d41fe7cce6ff"></a>
template&lt;class T , class Index &gt; </td></tr>
<tr class="memitem:af374fbc895ac5e033d59d41fe7cce6ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>minimaRemove</b> (const T *src, Index *indices, unsigned &amp;numIndices)</td></tr>
<tr class="separator:af374fbc895ac5e033d59d41fe7cce6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470ced746fcae7fcb3220ccc5b5d1182"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a470ced746fcae7fcb3220ccc5b5d1182"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a470ced746fcae7fcb3220ccc5b5d1182">mirror_dp</a> (T *arr, unsigned len)</td></tr>
<tr class="memdesc:a470ced746fcae7fcb3220ccc5b5d1182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies mirror isometry sequence [dp] from first half of array.  <a href="#a470ced746fcae7fcb3220ccc5b5d1182">More...</a><br /></td></tr>
<tr class="separator:a470ced746fcae7fcb3220ccc5b5d1182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c1914e1943dea2def236a02a6a7b82"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a86c1914e1943dea2def236a02a6a7b82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a86c1914e1943dea2def236a02a6a7b82">mirror_dq</a> (T *arr, unsigned len)</td></tr>
<tr class="memdesc:a86c1914e1943dea2def236a02a6a7b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies mirror isometry sequence [dq] from first half of array.  <a href="#a86c1914e1943dea2def236a02a6a7b82">More...</a><br /></td></tr>
<tr class="separator:a86c1914e1943dea2def236a02a6a7b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec27f2a9d4d4d3825c2962484ac178e8"><td class="memTemplParams" colspan="2"><a id="aec27f2a9d4d4d3825c2962484ac178e8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aec27f2a9d4d4d3825c2962484ac178e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#aec27f2a9d4d4d3825c2962484ac178e8">mul</a> (T *dst, const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:aec27f2a9d4d4d3825c2962484ac178e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply destination array by source array. <br /></td></tr>
<tr class="separator:aec27f2a9d4d4d3825c2962484ac178e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d538f7dbaafb0fcd1d27b71a7e710e9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8d538f7dbaafb0fcd1d27b71a7e710e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a8d538f7dbaafb0fcd1d27b71a7e710e9">mulBartlett</a> (T *arr, unsigned len)</td></tr>
<tr class="memdesc:a8d538f7dbaafb0fcd1d27b71a7e710e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply array by a Bartlett (triangle) window.  <a href="#a8d538f7dbaafb0fcd1d27b71a7e710e9">More...</a><br /></td></tr>
<tr class="separator:a8d538f7dbaafb0fcd1d27b71a7e710e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7dc8a48b34a8f5de67673cd2f02396"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5c7dc8a48b34a8f5de67673cd2f02396"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a5c7dc8a48b34a8f5de67673cd2f02396">mulHalfWindow</a> (T *arr, const T *src, unsigned len)</td></tr>
<tr class="separator:a5c7dc8a48b34a8f5de67673cd2f02396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f22bdcc8c82515cc7b86c57e59b43a3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4f22bdcc8c82515cc7b86c57e59b43a3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a4f22bdcc8c82515cc7b86c57e59b43a3">normalize</a> (T *arr, unsigned len, double scale=1)</td></tr>
<tr class="memdesc:a4f22bdcc8c82515cc7b86c57e59b43a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniformly scale array values to fit in [-1, 1].  <a href="#a4f22bdcc8c82515cc7b86c57e59b43a3">More...</a><br /></td></tr>
<tr class="separator:a4f22bdcc8c82515cc7b86c57e59b43a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414fed4aa88fc6e19bf9f81d6ae45f7d"><td class="memTemplParams" colspan="2"><a id="a414fed4aa88fc6e19bf9f81d6ae45f7d"></a>
template&lt;class T , template&lt; class &gt; class ArrayType&gt; </td></tr>
<tr class="memitem:a414fed4aa88fc6e19bf9f81d6ae45f7d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>normalize</b> (ArrayType&lt; T &gt; &amp;arr, double scale=1)</td></tr>
<tr class="separator:a414fed4aa88fc6e19bf9f81d6ae45f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436f98b063c0ad0afe5f809cc0047270"><td class="memTemplParams" colspan="2"><a id="a436f98b063c0ad0afe5f809cc0047270"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a436f98b063c0ad0afe5f809cc0047270"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a436f98b063c0ad0afe5f809cc0047270">norm</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a436f98b063c0ad0afe5f809cc0047270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns norm of array values. <br /></td></tr>
<tr class="separator:a436f98b063c0ad0afe5f809cc0047270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb70dcb9e69db08c1740f2cc07a9bfa"><td class="memTemplParams" colspan="2"><a id="a1bb70dcb9e69db08c1740f2cc07a9bfa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1bb70dcb9e69db08c1740f2cc07a9bfa"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a1bb70dcb9e69db08c1740f2cc07a9bfa">normTaxi</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a1bb70dcb9e69db08c1740f2cc07a9bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns taxicab norm of array values (sum of absolute values). <br /></td></tr>
<tr class="separator:a1bb70dcb9e69db08c1740f2cc07a9bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7e7acb42f534933085d864cb7d6702"><td class="memTemplParams" colspan="2"><a id="aca7e7acb42f534933085d864cb7d6702"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aca7e7acb42f534933085d864cb7d6702"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#aca7e7acb42f534933085d864cb7d6702">nyquist</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:aca7e7acb42f534933085d864cb7d6702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns unnormalized Nyquist value for use with <a class="el" href="classgam_1_1_d_f_t.html" title="Discrete Fourier transform. ">DFT</a>. <br /></td></tr>
<tr class="separator:aca7e7acb42f534933085d864cb7d6702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26211410927257c42b41811dbfa3a2cc"><td class="memTemplParams" colspan="2"><a id="a26211410927257c42b41811dbfa3a2cc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a26211410927257c42b41811dbfa3a2cc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a26211410927257c42b41811dbfa3a2cc">rms</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a26211410927257c42b41811dbfa3a2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns root mean square- the normalized norm. <br /></td></tr>
<tr class="separator:a26211410927257c42b41811dbfa3a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6d6daee5eaebc1777020c5a44a19c9"><td class="memTemplParams" colspan="2"><a id="a0d6d6daee5eaebc1777020c5a44a19c9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0d6d6daee5eaebc1777020c5a44a19c9"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a0d6d6daee5eaebc1777020c5a44a19c9">slopeAbsMax</a> (const T *src, unsigned len)</td></tr>
<tr class="memdesc:a0d6d6daee5eaebc1777020c5a44a19c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of absolute maximum slope in array. <br /></td></tr>
<tr class="separator:a0d6d6daee5eaebc1777020c5a44a19c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee27ac9b12344671ec71b11a38ff6477"><td class="memTemplParams" colspan="2"><a id="aee27ac9b12344671ec71b11a38ff6477"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aee27ac9b12344671ec71b11a38ff6477"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#aee27ac9b12344671ec71b11a38ff6477">slopeMax</a> (const T *src, unsigned len)</td></tr>
<tr class="memdesc:aee27ac9b12344671ec71b11a38ff6477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of maximum slope in array. <br /></td></tr>
<tr class="separator:aee27ac9b12344671ec71b11a38ff6477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb79dd62c4f3496f938a63b29a99b840"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb79dd62c4f3496f938a63b29a99b840"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#acb79dd62c4f3496f938a63b29a99b840">sortInsertion</a> (T *arr, unsigned len)</td></tr>
<tr class="memdesc:acb79dd62c4f3496f938a63b29a99b840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion sort of elements.  <a href="#acb79dd62c4f3496f938a63b29a99b840">More...</a><br /></td></tr>
<tr class="separator:acb79dd62c4f3496f938a63b29a99b840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7991032e84f3586a87e0f218f1c80633"><td class="memTemplParams" colspan="2">template&lt;class T , class Index &gt; </td></tr>
<tr class="memitem:a7991032e84f3586a87e0f218f1c80633"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a7991032e84f3586a87e0f218f1c80633">sortInsertion</a> (const T *src, Index *indices, unsigned numIndices)</td></tr>
<tr class="memdesc:a7991032e84f3586a87e0f218f1c80633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion sort of indexed elements.  <a href="#a7991032e84f3586a87e0f218f1c80633">More...</a><br /></td></tr>
<tr class="separator:a7991032e84f3586a87e0f218f1c80633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15659e89c104327307f167d12a09917"><td class="memTemplParams" colspan="2">template&lt;class T , class Index &gt; </td></tr>
<tr class="memitem:aa15659e89c104327307f167d12a09917"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#aa15659e89c104327307f167d12a09917">sortQuick</a> (const T *src, Index *indices, long beg, long end)</td></tr>
<tr class="memdesc:aa15659e89c104327307f167d12a09917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick sort of elements.  <a href="#aa15659e89c104327307f167d12a09917">More...</a><br /></td></tr>
<tr class="separator:aa15659e89c104327307f167d12a09917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863e0b55ceb8bd0235ca9a2bfa36ea0c"><td class="memTemplParams" colspan="2"><a id="a863e0b55ceb8bd0235ca9a2bfa36ea0c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a863e0b55ceb8bd0235ca9a2bfa36ea0c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a863e0b55ceb8bd0235ca9a2bfa36ea0c">sum</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a863e0b55ceb8bd0235ca9a2bfa36ea0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sum of values. <br /></td></tr>
<tr class="separator:a863e0b55ceb8bd0235ca9a2bfa36ea0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc305d2ad5f49c1210fdc282658fecee"><td class="memTemplParams" colspan="2"><a id="abc305d2ad5f49c1210fdc282658fecee"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abc305d2ad5f49c1210fdc282658fecee"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#abc305d2ad5f49c1210fdc282658fecee">variance</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:abc305d2ad5f49c1210fdc282658fecee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variance (deviation from mean). <br /></td></tr>
<tr class="separator:abc305d2ad5f49c1210fdc282658fecee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b8fcf4cd33c53039744bb559fe0911"><td class="memTemplParams" colspan="2"><a id="ad6b8fcf4cd33c53039744bb559fe0911"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad6b8fcf4cd33c53039744bb559fe0911"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#ad6b8fcf4cd33c53039744bb559fe0911">within</a> (const T *src, unsigned len, T threshold)</td></tr>
<tr class="memdesc:ad6b8fcf4cd33c53039744bb559fe0911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of values within [-threshold, theshold]. <br /></td></tr>
<tr class="separator:ad6b8fcf4cd33c53039744bb559fe0911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9667ddc599ca13b3514aadcd7814329"><td class="memTemplParams" colspan="2"><a id="aa9667ddc599ca13b3514aadcd7814329"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa9667ddc599ca13b3514aadcd7814329"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#aa9667ddc599ca13b3514aadcd7814329">within</a> (const T *src, unsigned len, T lo, T hi)</td></tr>
<tr class="memdesc:aa9667ddc599ca13b3514aadcd7814329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of values within [lo, hi]. <br /></td></tr>
<tr class="separator:aa9667ddc599ca13b3514aadcd7814329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67832f5fe4020121848c3ab7091ceae5"><td class="memTemplParams" colspan="2"><a id="a67832f5fe4020121848c3ab7091ceae5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a67832f5fe4020121848c3ab7091ceae5"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a67832f5fe4020121848c3ab7091ceae5">zeroCount</a> (const T *src, unsigned len, unsigned str=1)</td></tr>
<tr class="memdesc:a67832f5fe4020121848c3ab7091ceae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of values that equal zero. <br /></td></tr>
<tr class="separator:a67832f5fe4020121848c3ab7091ceae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f7685a88ce2d422f631d45beb33595"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a91f7685a88ce2d422f631d45beb33595">zeroCross</a> (const float *src, unsigned len, float prev)</td></tr>
<tr class="memdesc:a91f7685a88ce2d422f631d45beb33595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of zero-crossings in array.  <a href="#a91f7685a88ce2d422f631d45beb33595">More...</a><br /></td></tr>
<tr class="separator:a91f7685a88ce2d422f631d45beb33595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6279af592e5465f146f2c8ed79b90b90"><td class="memTemplParams" colspan="2"><a id="a6279af592e5465f146f2c8ed79b90b90"></a>
template&lt;class T , class Index &gt; </td></tr>
<tr class="memitem:a6279af592e5465f146f2c8ed79b90b90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zeroCross</b> (const T *src, unsigned len, Index &amp;nzc, Index &amp;pzc)</td></tr>
<tr class="separator:a6279af592e5465f146f2c8ed79b90b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2692d9c562e6e8287ced27dbf2cda9"><td class="memItemLeft" align="right" valign="top"><a id="aca2692d9c562e6e8287ced27dbf2cda9"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#aca2692d9c562e6e8287ced27dbf2cda9">zeroCrossFirst</a> (const float *src, unsigned len)</td></tr>
<tr class="memdesc:aca2692d9c562e6e8287ced27dbf2cda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of first zero-crossing or 0 if none detected. <br /></td></tr>
<tr class="separator:aca2692d9c562e6e8287ced27dbf2cda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c319af1efcff6c18d4adc6bd51b3de"><td class="memTemplParams" colspan="2"><a id="ac6c319af1efcff6c18d4adc6bd51b3de"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac6c319af1efcff6c18d4adc6bd51b3de"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zeroCrossMax</b> (const T *src, unsigned len)</td></tr>
<tr class="separator:ac6c319af1efcff6c18d4adc6bd51b3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1746666b46a8a1c45bd1fb2d464cbadb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegam_1_1arr.html#a1746666b46a8a1c45bd1fb2d464cbadb">zeroCrossN</a> (const float *src, unsigned len, float prev)</td></tr>
<tr class="memdesc:a1746666b46a8a1c45bd1fb2d464cbadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns # of negative slope zero-crossings.  <a href="#a1746666b46a8a1c45bd1fb2d464cbadb">More...</a><br /></td></tr>
<tr class="separator:a1746666b46a8a1c45bd1fb2d464cbadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8197289b6385c29753a30906df7d64b"><td class="memTemplParams" colspan="2"><a id="aa8197289b6385c29753a30906df7d64b"></a>
template&lt;class T , class T2 , class T3 &gt; </td></tr>
<tr class="memitem:aa8197289b6385c29753a30906df7d64b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lineFit</b> (const T *src, unsigned len, T2 &amp;slope, T3 &amp;inter)</td></tr>
<tr class="separator:aa8197289b6385c29753a30906df7d64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classgam_1_1_array.html" title="Resizable array. ">Array</a> rank functions for numerical types. </p>
<p>The following are names commonly used for input parameters. <br />
<br />
 'src' - array that will only be read from <br />
 'dst' - array that will be written to <br />
 'arr' - array that will be read from and written to, i.e. in-place <br />
 'len' - length of array <br />
 'stride' - how many elements to step through the array by <br />
Many of these functions are numerically generic meaning that the object is required to understand one or more of arithmetic operators +, -, *, \, and/or relational operators &lt;, &lt;=, &gt;, &gt;=. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2bf5cdbf8afae565d13f885df0d9e34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf5cdbf8afae565d13f885df0d9e34e">&#9670;&nbsp;</a></span>addToRing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned gam::arr::addToRing </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ringTap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum elements from src into ring-buffer ring. </p>
<p>Returns the next tap index. This will not guaranteed to be in the range [0, ringSize). </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00329">329</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                                                                                              {</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="keywordtype">unsigned</span> endTap = ringTap + len;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="keywordflow">if</span>(endTap &lt;= ringSize){     <span class="comment">// haven&#39;t gone past end</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        <a class="code" href="namespacegam_1_1arr.html#a57921e7a2bbcae73bf4e44c1390e9c41">add</a>(ring + ringTap, src, len);</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    }</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">else</span>{                       <span class="comment">// have gone past end, do wrapped addition</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        <span class="keywordtype">unsigned</span> samplesUnder   = ringSize - ringTap;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordtype">unsigned</span> samplesOver    = endTap - ringSize;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <a class="code" href="namespacegam_1_1arr.html#a57921e7a2bbcae73bf4e44c1390e9c41">add</a>(ring + ringTap, src, samplesUnder);</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        <a class="code" href="namespacegam_1_1arr.html#a57921e7a2bbcae73bf4e44c1390e9c41">add</a>(ring, src + samplesUnder, samplesOver);</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    }</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="keywordflow">return</span> endTap;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;}</div><div class="ttc" id="namespacegam_1_1arr_html_a57921e7a2bbcae73bf4e44c1390e9c41"><div class="ttname"><a href="namespacegam_1_1arr.html#a57921e7a2bbcae73bf4e44c1390e9c41">gam::arr::add</a></div><div class="ttdeci">void add(T *dst, const T *src, unsigned len, unsigned str=1)</div><div class="ttdoc">Add source array to destination array. </div><div class="ttdef"><b>Definition:</b> <a href="arr_8h_source.html#l00053">arr.h:53</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab464b6505e0c6447c31ae23dc53a2c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab464b6505e0c6447c31ae23dc53a2c00">&#9670;&nbsp;</a></span>cluster()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::cluster </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds elements that are within a threshold of their nearest neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source array of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Index array used for iterating the source array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Cluster indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numIndices</td><td>Number of source indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numIndices</td><td>Number of cluster indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Magnitude threshold of cluster. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00413">413</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                                                                               {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="keywordflow">if</span>(numIndices == 0) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    Index * newIndices = indices;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="keywordtype">unsigned</span> newNumIndices = 0;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    T prev = src[*indices++];</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordtype">bool</span> inCluster = <span class="keyword">false</span>;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    LOOP(numIndices - 1, 1){</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        Index index = *indices++;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        T curr = src[index];</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        <span class="keywordflow">if</span>( scl::abs(curr - prev) &lt;= threshold ){</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;            <span class="keywordflow">if</span>(!inCluster){</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                <span class="comment">// Add previous index</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                *newIndices++ = indices[-2];</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                ++newNumIndices;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;            }</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            <span class="comment">// Add current index</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            *newIndices++ = index;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            ++newNumIndices;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            inCluster = <span class="keyword">true</span>;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        }</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">else</span>{</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            inCluster = <span class="keyword">false</span>;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        }</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        prev = curr;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    }</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    numIndices = newNumIndices;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aff4b6b287382bc4c303acbcebcb3b2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4b6b287382bc4c303acbcebcb3b2fd">&#9670;&nbsp;</a></span>histogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ts , class Tb &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::histogram </td>
          <td>(</td>
          <td class="paramtype">const Ts *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tb *&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numBins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute histogram of 'src'. </p>
<p>Values in 'src' are tallied and placed in 'bins', where the index of the bin is the integer part of the source values. Source values greater than the number of bins are ignored. The scale and offset parameters can be used to put the src values into the proper range. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00496">496</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;                                                                                          {</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    LOOP(len, 1){</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        int32_t j = (int32_t)(src[i] * scale);</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        <span class="keywordflow">if</span>(j &gt;= 0 &amp;&amp; j &lt; (int32_t)numBins) bins[j]++;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    }</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a92adac78071b0c8c7b24c1de92a4cdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92adac78071b0c8c7b24c1de92a4cdbf">&#9670;&nbsp;</a></span>indicesComplement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::indicesComplement </td>
          <td>(</td>
          <td class="paramtype">Index *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxNumIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets indices [numIndices, maxNumIndices) to complement indices. </p>
<p>Indices must be sorted from low to high. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00859">859</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                                                                                    {</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;    Index * comp = indices + numIndices;</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;maxNumIndices; i++){</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;        <span class="keywordflow">if</span>(*indices == i)   ++indices;</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;        <span class="keywordflow">else</span>                *comp++ = i;</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;    }</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad2195070f4b560bcccb54c6928ddace6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2195070f4b560bcccb54c6928ddace6">&#9670;&nbsp;</a></span>lineFit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::lineFit </td>
          <td>(</td>
          <td class="paramtype">const T1 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>slope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T3 &amp;&#160;</td>
          <td class="paramname"><em>inter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform linear least squares fitting of array. </p>
<p>This computes the linear equation 'y = slope * x + inter' that best fits the array values in a least squares sense. Here, the independent variable, x, is the array index and the dependent variable, y, is the array element value. </p>

</div>
</div>
<a id="a6cb6b3bbf615b929f0091d329bc96eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb6b3bbf615b929f0091d329bc96eb0">&#9670;&nbsp;</a></span>maxima()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Index , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned gam::arr::maxima </td>
          <td>(</td>
          <td class="paramtype">Index *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>str</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates local maxima and writes their indices into 'dst'. </p>
<p>Returns number of maxima found. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00572">572</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                                                                       {</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    T prev = src[0];</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    T curr = src[str];</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    </div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    <span class="keywordtype">unsigned</span> numPeaks = 0;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    </div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=(str&lt;&lt;1); i&lt;len; i+=str){</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        T next = src[i];</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        <span class="keywordflow">if</span>(curr &gt; prev &amp;&amp; curr &gt; next){</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;            *dst++ = i-str;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;            ++numPeaks;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            i+=str;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;            <span class="keywordflow">if</span>(i&lt;len){</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;                prev = next;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                curr = src[i];</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;            }</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;        }</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;        <span class="keywordflow">else</span>{</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;            prev = curr;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;            curr = next;</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;        }</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    }</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="keywordflow">return</span> numPeaks;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="af560cea1ff06a08c31604c2ae2956e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af560cea1ff06a08c31604c2ae2956e38">&#9670;&nbsp;</a></span>meanWeighted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gam::arr::meanWeighted </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns weighted mean of array values. </p>
<p>Weights must be positive. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00625">625</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                                                              {</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    T <a class="code" href="namespacegam_1_1arr.html#ac18472e15b3a6a707c1c0dfc4c2f04dd">mean</a> = T(0);</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    <span class="comment">// One loop: faster, but less accurate</span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="comment">//  LOOP(len,</span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="comment">//      mean += *src++ * *weight;</span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="comment">//      normFactor += *weight++;</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="comment">//  )</span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="comment">//  return mean /= normFactor;</span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    <span class="comment">// Two loops: slower, but avoids overflow</span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    T normFactor = T(1) / <a class="code" href="namespacegam_1_1arr.html#a863e0b55ceb8bd0235ca9a2bfa36ea0c">sum</a>(weights, len);</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    LOOP(len,1){ mean += *src++ * *weights++ * normFactor; }</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    <span class="keywordflow">return</span> mean;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;}</div><div class="ttc" id="namespacegam_1_1arr_html_a863e0b55ceb8bd0235ca9a2bfa36ea0c"><div class="ttname"><a href="namespacegam_1_1arr.html#a863e0b55ceb8bd0235ca9a2bfa36ea0c">gam::arr::sum</a></div><div class="ttdeci">T sum(const T *src, unsigned len, unsigned str=1)</div><div class="ttdoc">Returns sum of values. </div><div class="ttdef"><b>Definition:</b> <a href="arr_8h_source.html#l00776">arr.h:776</a></div></div>
<div class="ttc" id="namespacegam_1_1arr_html_ac18472e15b3a6a707c1c0dfc4c2f04dd"><div class="ttname"><a href="namespacegam_1_1arr.html#ac18472e15b3a6a707c1c0dfc4c2f04dd">gam::arr::mean</a></div><div class="ttdeci">T mean(const T *src, unsigned len, unsigned str=1)</div><div class="ttdoc">Returns the mean (average) value of array values. </div><div class="ttdef"><b>Definition:</b> <a href="arr_8h_source.html#l00600">arr.h:600</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a367de7e8249571e06fc9eaa44c3852ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367de7e8249571e06fc9eaa44c3852ff">&#9670;&nbsp;</a></span>meanWeightedIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gam::arr::meanWeightedIndex </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns weighted mean in [0, len) of indices of weights. </p>
<p>Weights must be positive. Can be used to compute centroid of spectrum. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00642">642</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                                                    {</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    T <a class="code" href="namespacegam_1_1arr.html#ac18472e15b3a6a707c1c0dfc4c2f04dd">mean</a> = T(0);</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    T normFactor = <a class="code" href="namespacegam_1_1arr.html#a863e0b55ceb8bd0235ca9a2bfa36ea0c">sum</a>(weights, len);</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="keywordflow">if</span>(normFactor == T(0)) <span class="keywordflow">return</span> T(0);</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    normFactor = T(1) / normFactor;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    T weightFactor = T(0);</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    LOOP(len,1){</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;        mean += *weights++ * weightFactor;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        weightFactor += normFactor;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;    }</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    <span class="keywordflow">return</span> mean;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;}</div><div class="ttc" id="namespacegam_1_1arr_html_a863e0b55ceb8bd0235ca9a2bfa36ea0c"><div class="ttname"><a href="namespacegam_1_1arr.html#a863e0b55ceb8bd0235ca9a2bfa36ea0c">gam::arr::sum</a></div><div class="ttdeci">T sum(const T *src, unsigned len, unsigned str=1)</div><div class="ttdoc">Returns sum of values. </div><div class="ttdef"><b>Definition:</b> <a href="arr_8h_source.html#l00776">arr.h:776</a></div></div>
<div class="ttc" id="namespacegam_1_1arr_html_ac18472e15b3a6a707c1c0dfc4c2f04dd"><div class="ttname"><a href="namespacegam_1_1arr.html#ac18472e15b3a6a707c1c0dfc4c2f04dd">gam::arr::mean</a></div><div class="ttdeci">T mean(const T *src, unsigned len, unsigned str=1)</div><div class="ttdoc">Returns the mean (average) value of array values. </div><div class="ttdef"><b>Definition:</b> <a href="arr_8h_source.html#l00600">arr.h:600</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a470ced746fcae7fcb3220ccc5b5d1182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470ced746fcae7fcb3220ccc5b5d1182">&#9670;&nbsp;</a></span>mirror_dp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::mirror_dp </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies mirror isometry sequence [dp] from first half of array. </p>
<p>The sequence of mirror isometries are identity (d) and rotation (p). The first len/2 elements of the array are mirrored.<br />
Ex.: [ 1, 2, 3, 4, x, x, x, x] -&gt; [ 1, 2, 3, 4,-4,-3,-2,-1] </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00360">360</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                                            {</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    T * arr2 = arr + len - 1;   <span class="comment">// 2nd half end</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    LOOP(len, 2){ *arr2-- = -*arr++; }</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a86c1914e1943dea2def236a02a6a7b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c1914e1943dea2def236a02a6a7b82">&#9670;&nbsp;</a></span>mirror_dq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::mirror_dq </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies mirror isometry sequence [dq] from first half of array. </p>
<p>The sequence of mirror isometries are identity (d) and glide relfection (q). The first len/2 elements of the array are mirrored.<br />
Ex.: [ 1, 2, 3, 4, x, x, x, x] -&gt; [ 1, 2, 3, 4,-1,-2,-3,-4] </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00366">366</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                                            {</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    T * arr2 = arr + (len&gt;&gt;1);  <span class="comment">// 2nd half begin</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    LOOP(len, 2){ *arr2++ = -*arr++; }</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8d538f7dbaafb0fcd1d27b71a7e710e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d538f7dbaafb0fcd1d27b71a7e710e9">&#9670;&nbsp;</a></span>mulBartlett()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::mulBartlett </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply array by a Bartlett (triangle) window. </p>
<p>Works only for even sized arrays. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00372">372</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                                              {</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    T * end = arr + len - 1;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="keywordtype">unsigned</span> len_2 = len &gt;&gt; 1;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="keyword">const</span> T <a class="code" href="namespacegam_1_1scl.html#a6993914e45b9937b5da0d3b501a43562">slope</a> = (T)1. / (T)len_2;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    T line = slope;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    </div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    *arr++ = (T)0;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    LOOP(len_2 - 1, 1){</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        *arr++ *= line;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        *end-- *= line;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        line += slope;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    }</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;}</div><div class="ttc" id="namespacegam_1_1scl_html_a6993914e45b9937b5da0d3b501a43562"><div class="ttname"><a href="namespacegam_1_1scl.html#a6993914e45b9937b5da0d3b501a43562">gam::scl::slope</a></div><div class="ttdeci">T slope(T x1, T y1, T x2, T y2)</div><div class="ttdoc">Returns slope of line passing through two points. </div><div class="ttdef"><b>Definition:</b> <a href="scl_8h_source.html#l01037">scl.h:1037</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c7dc8a48b34a8f5de67673cd2f02396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7dc8a48b34a8f5de67673cd2f02396">&#9670;&nbsp;</a></span>mulHalfWindow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::mulHalfWindow </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply 'arr' by 'src' where 'src' is the first 'len'/2 + 1 elements of a symmetric window. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00387">387</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                                                               {</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    T * end = arr + len - 1;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    len &gt;&gt;= 1;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    </div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    *arr++ *= *src++;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    LOOP(len - 1, 1){</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        <span class="keyword">const</span> T val = *src++;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        *arr++ *= val;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        *end-- *= val;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    }</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    *arr *= *src;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4f22bdcc8c82515cc7b86c57e59b43a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f22bdcc8c82515cc7b86c57e59b43a3">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double gam::arr::normalize </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniformly scale array values to fit in [-1, 1]. </p>
<p>Returns the applied normalization multiplication factor. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00401">401</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                                                     {</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordtype">double</span> <a class="code" href="namespacegam_1_1scl.html#aef3edea911471eec67a80c4c8dc6d046">max</a> = gam::norm(arr[<a class="code" href="namespacegam_1_1arr.html#a9da18a9b7134245dd2dd387bdca00b04">indexOfMaxNorm</a>(arr, len)]);</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordtype">double</span> normFactor = <a class="code" href="namespacegam_1_1mem.html#a21135a4123adc9bbfcca511c51f01b50">scale</a>/max;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    <span class="keywordflow">if</span>(max != 0.){</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;len; ++i){</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;            arr[i]*=normFactor;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        }</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    }</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="keywordflow">return</span> normFactor;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;}</div><div class="ttc" id="namespacegam_1_1scl_html_aef3edea911471eec67a80c4c8dc6d046"><div class="ttname"><a href="namespacegam_1_1scl.html#aef3edea911471eec67a80c4c8dc6d046">gam::scl::max</a></div><div class="ttdeci">T max(T v1, T v2, T v3)</div><div class="ttdoc">Returns maximum of three values. </div><div class="ttdef"><b>Definition:</b> <a href="scl_8h_source.html#l01031">scl.h:1031</a></div></div>
<div class="ttc" id="namespacegam_1_1mem_html_a21135a4123adc9bbfcca511c51f01b50"><div class="ttname"><a href="namespacegam_1_1mem.html#a21135a4123adc9bbfcca511c51f01b50">gam::mem::scale</a></div><div class="ttdeci">void scale(T *dst, const T *src, unsigned lenSrc, float stride)</div><div class="ttdoc">Copies elements from &amp;#39;src&amp;#39; to fractionally strided locations in &amp;#39;dst&amp;#39;. </div><div class="ttdef"><b>Definition:</b> <a href="mem_8h_source.html#l00540">mem.h:540</a></div></div>
<div class="ttc" id="namespacegam_1_1arr_html_a9da18a9b7134245dd2dd387bdca00b04"><div class="ttname"><a href="namespacegam_1_1arr.html#a9da18a9b7134245dd2dd387bdca00b04">gam::arr::indexOfMaxNorm</a></div><div class="ttdeci">unsigned indexOfMaxNorm(const T *src, unsigned len, unsigned str=1)</div><div class="ttdoc">Returns index of maximum normed value (i.e., magnitude) </div><div class="ttdef"><b>Definition:</b> <a href="arr_8h_source.html#l00523">arr.h:523</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acb79dd62c4f3496f938a63b29a99b840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb79dd62c4f3496f938a63b29a99b840">&#9670;&nbsp;</a></span>sortInsertion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::sortInsertion </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insertion sort of elements. </p>
<p>Elements are sorted from lowest to highest. This sort is fastest for small length arrays and mostly sorted sets. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00730">730</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;                                         {</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 1; i &lt; len; i++){</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        T val = arr[i];</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;        <span class="keywordtype">unsigned</span> j = i - 1;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;        <span class="keywordflow">for</span>(; (j &lt; len) &amp;&amp; (arr[j] &gt; val); j--){</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;            arr[j + 1] = arr[j];                                      </div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;        }</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;        arr[j + 1] = val;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;    } </div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a7991032e84f3586a87e0f218f1c80633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7991032e84f3586a87e0f218f1c80633">&#9670;&nbsp;</a></span>sortInsertion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::sortInsertion </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insertion sort of indexed elements. </p>
<p>Elements are sorted from lowest to highest. This sort is fastest for small length arrays and mostly sorted sets. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00742">742</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;                                                                       {</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 1; i &lt; numIndices; i++)</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    {</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;        Index index = indices[i];</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        T val = src[index];</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        <span class="keywordtype">unsigned</span> j = i - 1;</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        <span class="keywordflow">while</span>((j &lt; numIndices) &amp;&amp; (val &lt; src[indices[j]]))</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        {</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;            indices[j + 1] = indices[j]; </div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            --j;                                         </div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        }</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;        indices[j + 1] = index;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    } </div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa15659e89c104327307f167d12a09917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15659e89c104327307f167d12a09917">&#9670;&nbsp;</a></span>sortQuick()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gam::arr::sortQuick </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quick sort of elements. </p>
<p>Elements are sorted from lowest to highest. </p>

<p class="definition">Definition at line <a class="el" href="arr_8h_source.html#l00758">758</a> of file <a class="el" href="arr_8h_source.html">arr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                                                                  {</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;    <span class="comment">// must be at least 1 element to sort</span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    <span class="keywordflow">if</span>(end &gt; beg + 1) {</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        <span class="keywordtype">long</span> piv = indices[beg], l = beg + 1, r = end;</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;        T pivVal = src[piv];</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;        <span class="keywordflow">while</span> (l &lt; r){</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            <span class="keywordflow">if</span> ( src[indices[l]] &lt;= pivVal ) </div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                l++;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;            <span class="keywordflow">else</span> </div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                mem::swap(indices[l], indices[--r]);</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;        }</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;        mem::swap(indices[--l], indices[beg]);</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        <a class="code" href="namespacegam_1_1arr.html#aa15659e89c104327307f167d12a09917">sortQuick</a>(src, indices, beg, l);</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;        <a class="code" href="namespacegam_1_1arr.html#aa15659e89c104327307f167d12a09917">sortQuick</a>(src, indices, r, end);</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    }</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;}</div><div class="ttc" id="namespacegam_1_1arr_html_aa15659e89c104327307f167d12a09917"><div class="ttname"><a href="namespacegam_1_1arr.html#aa15659e89c104327307f167d12a09917">gam::arr::sortQuick</a></div><div class="ttdeci">void sortQuick(const T *src, Index *indices, long beg, long end)</div><div class="ttdoc">Quick sort of elements. </div><div class="ttdef"><b>Definition:</b> <a href="arr_8h_source.html#l00758">arr.h:758</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a91f7685a88ce2d422f631d45beb33595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f7685a88ce2d422f631d45beb33595">&#9670;&nbsp;</a></span>zeroCross()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned gam::arr::zeroCross </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of zero-crossings in array. </p>
<p>'prev' is the last value from the previous buffer. </p>

</div>
</div>
<a id="a1746666b46a8a1c45bd1fb2d464cbadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1746666b46a8a1c45bd1fb2d464cbadb">&#9670;&nbsp;</a></span>zeroCrossN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned gam::arr::zeroCrossN </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns # of negative slope zero-crossings. </p>
<p>'prev' is the last value from the previous buffer. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>gam</b></li><li class="navelem"><a class="el" href="namespacegam_1_1arr.html">arr</a></li>
    <li class="footer">Generated on Tue Apr 10 2018 11:13:13 for Allolib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
